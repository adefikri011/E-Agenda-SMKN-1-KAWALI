<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Drawing Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #f5f5f5;
        }

        h1 {
            color: #333;
        }

        .canvas-container {
            background: white;
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        canvas {
            border: 1px solid #999;
            border-radius: 4px;
            width: 100%;
            height: 250px;
            display: block;
            cursor: crosshair;
            background: white;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 10px 10px 0;
        }

        button:hover {
            background: #0056b3;
        }

        button.danger {
            background: #dc3545;
        }

        button.danger:hover {
            background: #c82333;
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 14px;
        }

        .info p {
            margin: 5px 0;
        }

        .status {
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            font-weight: bold;
        }

        .status.drawing {
            background: #d4edda;
            color: #155724;
        }

        .status.ready {
            background: #d1ecf1;
            color: #0c5460;
        }
    </style>
</head>
<body>
    <h1>üé® Canvas Drawing Test</h1>
    <p>Test canvas drawing functionality for signature pad.</p>

    <div class="canvas-container">
        <p><strong>Draw here with your mouse or touch:</strong></p>
        <canvas id="testCanvas"></canvas>

        <button id="clearBtn" class="danger">üóëÔ∏è Clear Drawing</button>
        <button id="saveBtn">üíæ Save as Image</button>

        <div id="status" class="status ready">
            ‚úì Ready to draw
        </div>
    </div>

    <div class="info">
        <p><strong>Canvas Info:</strong></p>
        <p>Device Pixel Ratio: <span id="dprInfo">-</span></p>
        <p>Canvas Dimensions (CSS): <span id="cssSize">-</span></p>
        <p>Canvas Dimensions (Real): <span id="realSize">-</span></p>
        <p>Drawing Data Size: <span id="dataSize">-</span> bytes</p>
        <p>Drawing Status: <span id="drawingStatus">No drawing yet</span></p>
    </div>

    <script>
        const canvas = document.getElementById('testCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        let isDrawing = false;
        let hasDrawing = false;

        // Initialize canvas
        function initCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            // Use setTransform to avoid accumulating scale transforms on repeated init
            if (typeof ctx.setTransform === 'function') {
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            } else {
                ctx.scale(dpr, dpr);
            }
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Update info
            document.getElementById('dprInfo').textContent = dpr;
            document.getElementById('cssSize').textContent = `${rect.width}px √ó ${rect.height}px`;
            document.getElementById('realSize').textContent = `${canvas.width}px √ó ${canvas.height}px`;

            console.log('‚úì Canvas initialized:', { dpr, width: rect.width, height: rect.height });
        }

        // Get coordinates
        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            let x, y;

            if (e.touches && e.touches.length > 0) {
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }

            return { x, y };
        }

        // Drawing events
        function startDrawing(e) {
            if (e.target !== canvas) return;
            e.preventDefault();

            isDrawing = true;
            hasDrawing = true;

            const { x, y } = getCoords(e);
            ctx.beginPath();
            ctx.moveTo(x, y);

            updateStatus('drawing');
            console.log('üñäÔ∏è Started drawing at:', x, y);
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();

            const { x, y } = getCoords(e);
            ctx.lineTo(x, y);
            ctx.stroke();
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            e.preventDefault();

            isDrawing = false;
            ctx.closePath();

            updateStatus('ready');
            updateDataSize();
            console.log('‚úì Stopped drawing');
        }

        // Clear canvas
        document.getElementById('clearBtn').addEventListener('click', (e) => {
            e.preventDefault();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            hasDrawing = false;
            document.getElementById('drawingStatus').textContent = 'Cleared';
            updateDataSize();
        });

        // Save image
        document.getElementById('saveBtn').addEventListener('click', (e) => {
            e.preventDefault();
            if (!hasDrawing) {
                alert('‚ö†Ô∏è Nothing to save. Please draw first!');
                return;
            }

            const dataUrl = canvas.toDataURL('image/png');
            document.getElementById('dataSize').textContent = dataUrl.length;

            // Create download link
            const link = document.createElement('a');
            link.href = dataUrl;
            link.download = 'drawing.png';
            link.click();

            alert('‚úì Image saved! Data URL length: ' + dataUrl.length + ' characters');
            console.log('‚úì Image saved with data URL length:', dataUrl.length);
        });

        // Event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);

        // Helper functions
        function updateStatus(status) {
            const statusEl = document.getElementById('status');
            if (status === 'drawing') {
                statusEl.textContent = 'üñäÔ∏è Drawing...';
                statusEl.className = 'status drawing';
            } else {
                statusEl.textContent = '‚úì Ready to draw';
                statusEl.className = 'status ready';
            }
        }

        function updateDataSize() {
            if (hasDrawing) {
                const dataUrl = canvas.toDataURL('image/png');
                document.getElementById('dataSize').textContent = dataUrl.length;
                document.getElementById('drawingStatus').textContent = `Drawing present (${dataUrl.length} bytes)`;
            }
        }

        // Initialize on load
        window.addEventListener('load', initCanvas);
        initCanvas();

        console.log('Canvas test page loaded');
    </script>
</body>
</html>
